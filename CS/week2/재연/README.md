<strong>목차</strong>

[1. HTTP와 HTTPS](#HTTP와-HTTPS)

[2. 대칭키와 공개키](#대칭키와-공개키)

[3. 로드밸런싱](#로드밸런싱)

[4. Blocking과 Non-Blocking](#Blocking과-Non-Blocking)



## HTTP와 HTTPS

<h4>HTTP</h4>

HTTP(Hyper Text Transfer Protocol)는 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.

HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이기도 하다.

클라이언트와 서버는 메시지 교환을 통해 통신을 하게되는데 클라이언트가 보내는 메시지를 요청(request)라고 하고 서버에서 응답으로 전송되는 메시지를 응답(response)라고 부른다.



<h4>HTTPS</h4>

HTTPS는 HTTP 프로토콜의 보안 버전이다.

보안은 SSL(Secure Socket Layer)/TLS(Transport Layer Security) 프로토콜 암호화한다.





## 대칭키와 공개키

<h4>대칭키</h4>

대칭키란 암호화와 복호화를 하는데에 사용하는 키가 동일한 암호화 방식을 의미한다.

DES, 3DES, AES, SEED, ARIA 등의 알고리즘이 있다.

공개키 암호화 방식에 비해 속도가 빠르다.

하지만 키를 교환해야하는 문제가 발생한다.

키를 교환하는 중에 탈취가 될 수 있고, 이용자가 많아질수록 관리해야되는 키의 양이 많아진다.



<h4>공개키</h4>

대칭키의 문제점인 키 교환 문제를 해결하기 위해 등장한 것이다.

키가 공개되어 있는 공개키와 각 개인이 소유하는 개인키가 있다.

A에게 데이터를 전송하고 싶으면 A의 공개키로 데이터를 암호화한 후 A에게 보내면 A는 자신의 개인키로 메시지를 복호화하여 데이터를 볼 수 있다.

매우 큰 소수를 이용하여 암호화를 하기 때문에 이를 복호화 하는데에도 시간이 오래 걸려 대칭키보다 느리다.

RSA 알고리즘이 있다.





## 로드밸런싱

로드 밸런싱은 서버에 가해지는 부하(로드)를 분산(밸런싱)하는 장치 또는 기술을 의미한다.

웹사이트의 접속 인원이 급증함에 따라 서버가 이 트래픽을 모두 견딜 수가 없다.

이러한 현상에 대한 대응 방안으로 하드웨어의 성능을 올리는 Scale-up과 서버를 추가하여 여러 대의 서버가 나눠서 일하도록 만드는 것을 Scale-out이다.

- 하드웨어의 값이 비싸 Scale-out이 효과적이다.

여기서 여러 대의 서버에게 트래픽을 균등하게 분산시켜주는 것이 로드 밸런싱이다.



로드 밸런싱 알고리즘

- 라운드 로빈
- 가중 라운드 로빈
- 최소 연결 방식
- IP 해시 방식



<h4>L4 로드 밸런싱</h4>

4계층인 Tranport 계층에서 로드를 분산한다.

TCP, UDP 포트 정보를 바탕으로 분산한다.

데이터 안을 보지 않고 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높다.

섬세한 라우팅이 불가능하지만 L7 밸런서보다 저렴하다.



<h4>L7 로드 밸런싱</h4>

7계층인 Application 계층에서 로드를 분산한다.

HTTP 헤더, 쿠키 등 사용자 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다.

즉, 패킷 내용을 확인하고 그 내용에 따라 서버에 분배하는 것이 가능하다.

섬세한 라우팅이 가능하고, 비정상적인 트래픽을 필터링 할 수 있다.

패킷을 복호화해야 하기 때문에 비용이 많이 든다.

로드 밸런싱을 이중화하여 장애를 대비한다.





## Blocking과 Non-Blocking

<h4>Blocking</h4>

블로킹은 호출된 함수가 자신의 작업을 모두 끝날 때까지 제어권을 가지고 있어 호출한 함수가 대기하도록 만드는 것이다.

<h4>Non-Blocking</h4>

호출된 함수가 바로 return 해서 호출한 함수에게 제어권을 주어 다른 일을 할 수 있게 하는 것이다.

호출되는 함수가 바로 리턴하느냐 마느냐가 중점이다.



<strong>sync와 async, blocking과 non-blocking</strong>

- Synchronous는 호출하는 함수가 호출되는 함수의 작업 완료 후 return을 기다리거나, 호출되는 함수로부터 return을 받아도 작업 완료 여부를 계속 신경 쓰는 것이다.
- Asynchronous는 호출되는 함수에게 callback을 전달하고, 호출되는 함수는 작업이 완료되면 전달받은 callback을 실행하는 것으로 호출되는 함수의 작업을 callback이 신경쓰도록 하는 것이다.
- sync와 async는 대상들의 시간이 맞추는가, 맞추기 않는가이다.
- blocking과 non-blocking은 제어권이 반환되는가, 되지 않는가이다.



보면 이해하기 좋은 영상

[우의 Block vs Non-Block & Sync vs Async](https://www.youtube.com/watch?v=IdpkfygWIMk)