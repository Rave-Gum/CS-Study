<strong>목차</strong>

[1. 메모리](#메모리)

[2. 파일시스템](#파일시스템)

[3. 페이징과 세그먼테이션](#페이징과-세그먼테이션)

[4. 페이지 교체 알고리즘](#페이지-교체-알고리즘)



## 메모리

메모리는 CPU가 직접 접근할 수 있는 기억장치로, 메인 메모리와 캐시 메모리로 구분된다.

<strong>메인 메모리</strong>

- 메인 메모리를 RAM(Random Access Memory)라고도 한다.
  - RAM에는 DRAM과 SRAM이 있는데, 메인 메모리에는 DRAM을 캐시메모리에는 SRAM을 사용한다.
  - DRAM(Dynamic RAM)은 동적 메모리를 의미한다.
    - 전원이 계속 공급되어도 주기적으로 재충전되어야 기억된 내용을 유지할 수 있다.
  - SRAM(Static RAM)은 정적 메모리를 의미한다.
    - 전원이 공급되는 동안 기록된 내용이 지워지지 않아 재충전이 필요없다.
      - 속도가 빠르지만, 가격이 비싸다는 단점이 있다.

- 메인 메모리는 주소가 할당된 일련의 바이트들로 구성되어 있다.



<strong>메모리 관리 장치(Memory Management Unit)</strong>

- CPU는 레지스터가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져오는데, 메모리에 필요한 명령어가 없다면 해당 데이터를 우선으로 가져오는 역할을 한다.
- 논리 주소를 물리 주소로 바꿔주는 역할을 한다.
  - 메모리의 공간은 한정적이기 때문에 사용자에게 많은 메모리를 제공하기 위해 가상 주소라는 개념이 생겨났다.
- 메모리 보호, 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리 해주는 하드웨어이다.



<strong>가상 메모리(Virtual Memory)</strong>

- 메모리 관리 방법의 하나로, 각각의 프로세스에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당해 주는 방식을 의미한다.
- 코드를 구현하는 사람이 주소를 할당하는데에 신경을 쓰지 않아도 된다.
  - 물리적 주소로 하나하나 할당하는 행위를 하지 않아도 됨



<strong>MMU의 메모리 보호</strong>

- 프로세스는 독립적인 메모리를 할당받고, 자신의 영역에만 접근할 수 있다.

  이러한 영역을 벗어난 접근이 생길 경우 trap을 발생시키며 보호한다.

- base와 limit레지스터를 활용한 메모리 보호 기법

  - base 레지스터는 메모리상의 프로세스 시작 주소를 물리 주소로 저장한다.
  - limit 레지스터는 프로세스의 사이즈를 저장한다.
  - 두 개의 레지스터를 사용하여 프로세스의 접근 가능 영역을 설정할 수 있다.
    - base <= x < base + limit
  - 안정성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계한다.



<strong>메모리 과할당</strong>

- 가상 메모리를 사용하면 메모리를 실제 메모리보다 많은 메모리를 할당하게 된다.
  - 과할당으로 인해 사용자를 속인 것이 들킬 수 있음
    - 프로세스 실행 도중 페이지 폴트 발생
    - 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
    - 모든 메모리가 사용 중이라, 빈 프레임이 없음
  - 빈 프레임을 확보하기 위한 2가지 방법이 있다.
    - 메모리에 올라와 있는 프로세스 하나를 종료시켜 빈 프레임을 확보한다.
      - 사용자가 알 확률이 매우 높아 사용하지 못하는 방법
    - 프로세스 하나를 Swap Out하여 빈 프레임을 확보한다.
      - 이 방법을 사용하기 위해 페이지 교체 알고리즘이 필요하다.



<strong>페이지 교체</strong>

- 페이지 교체는 메모리 과할당이 발생했을 때, 프로세스 하나를 swap out하여 빈 프레임을 확보하는 것이다.
- 페이지 교체의 순서
  - 프로세스 실행 도중 페이지 부재 발생
  - 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
  - 메모리에 빈 프레임이 있는지 확인
    - 있다면 해당 프레임 사용
    - 없다면 victim 프레임을 선정해 디스크에 기록하고 페이지 테이블을 업데이트함
  - 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고 페이지 테이블 업데이트
- 페이지 교체는 사용자가 알지 못하도록 해야 하므로 오버헤드가 작아야 한다.
  - 메모리에 빈 프레임이 없다면 victim 프레임을 비울 때와 원하는 페이지를 프레임으로 올릴 때 두 번의 디스크 접근이 이루어진다.
    따라서 페이지 교체가 많이 일어나면 입출력 연산이 많아져 오버헤드가 커진다.
  - 페이지 교체를 줄이기 위해서는 두 가지 방법이 있다.
    - 페이지마다 변경 비트를 두어 페이지에 변화가 있다면 디스크에 기록하고, 페이지에 변화가 없다면 디스크에 기록하지 않는다.
    - 페이지 교체 알고리즘을 상황에 따라 잘 선택해야 한다.



<strong>캐시 메모리</strong>

- 주기억장치(메인 메모리)에 저장된 내용의 일부를 저장해두는 기억장치이다.
- CPU와 주기억장치의 속도 차이로 인해 성능 저하를 방지하기 위한 방법이다.
- 캐시메모리는 플리플롭 소자를 사용한 SRAM이기 때문에 DRAM보다 빠르다.
- 캐시 메모리와 CPU의 상호작용
  - CPU에서 주소를 전달하여 캐시 메모리에 명령이 존재하는지 확인한다.
  - 존재(Hit)하면 해당 명령어를 CPU로 전송한다.
  - 존재하지 않으면(Miss) 주기억 장치로 접근하여 해당 명령어를 가진 데이터를 인출하고, 해당 명령어를 캐시에 저장 후 CPU로 전송한다.



<strong>지역성</strong>

- 캐시 메모리를 잘 활용하면 주기억장치까지 가지 않아도 되므로 비용을 줄일 수 있다.
  - 즉, 적중률이 높아 Hit를 많이 할 수록 비용이 많이 줄어든다.
  - 적중률을 높이기 위해 사용되는 원리가 지역성의 원리이다.
- 지역성은 시간 지역성과 공간 지역성이 있다.
  - 시간 지역성
    - 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
  - 공간 지역성
    - 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성



<strong>캐싱 라인</strong>

- 빈번하게 사용되는 데이터들을 캐시에 저장해두었더라도, 필요한 데이터를 위해 캐시의 모든 데이터를 순회하는 것은 시간낭비이다.
- 캐시에 데이터를 저장할 때, 자료구조를 활용해 묶어서 저장하는 방법을 캐싱 라인이라고 한다.
- Set이나 Map 등을 활용하여 데이터와 데이터의 메모리 주소를 함께 저장하여 빠르게 원하는 정보를 찾을 수 있다.





## 파일시스템

컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법이다.



<strong>특징</strong>

- 커널 영역에서 동작한다.
- 파일 CRUD 기능을 원활히 수행하기 위한 목적이다.
- 계층적 디렉터리 구조를 가진다.
- 디스크 파티션 별로 하나씩 둘 수 있다.



<strong>역할</strong>

- 파일 관리: 파일 저장, 참조, 공유
- 보조 저장소 관리: 저장 공간 할당
- 파일 무결성 메커니즘
- 접근 방법: 저장된 데이터에 접근할 수 있는 방법 제공



<strong>개발 목적</strong>

- 하드디스크와 메인 메모리의 속도차를 줄이기 위해서
- 파일을 관리하기 위해서
- 하드디스크 용량을 효율적으로 사용하기 위해서



<strong>구조</strong>

- 메타영역: 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간 정보, 삭제 유무 등의 파일 정보
- 데이터 영역: 파일의 데이터



<strong>접근 방법</strong>

- 순차 접근
  - 현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행한다. 뒤로 돌아갈 때는 지정한 offset만큼 되감기를 해야 한다.
- 직접 접근
  - 특별한 순서 없이, 빠르게 레코드를 read, write 할 수 있는 방법
- 기타 접근
  - 직접 접근 파일에 기반하여 색인을 구축하는 방법



<strong>디렉터리와 디스크 구조</strong>

- 1단계 디렉터리
  - 파일들은 서로 유일한 이름을 가지고 다른 사용자라도 같은 이름 사용이 불가
- 2단계 디렉터리
  - 사용자에게 개별적인 디렉터리를 만들어줌
  - 사용자마다 1단계 디렉터리를 각각 가지고 있는 방식
- 트리 구조 디렉터리
  - 2단계에서 확장된 다단계 트리 구조
  - 한 비트를 활용하여 일반 파일(0)인지 디렉터리 파일(1)인지 구분
- 그래프 구조 디렉터리
  - 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시





## 페이징과 세그먼테이션

<strong>메모리 관리 기법</strong>

- 연속 메모리 관리
  - 프로그램 전체를 하나의 공간에 연속적으로 할당하는 방법이다.
  - 고정 분할 기법과 동적 분할 기법이 있다.
    - 고정 분할 기법: 주기억장치를 고정된 파티션으로 분할하는 방법
      - 내부, 외부 단편화가 발생한다.
    - 동적 분할 기법: 파티션들이 동적으로 생성되며 자신의 크기와 같은 파티션에 적재하는 방법
      - 외부 단편화가 발생한다.
  - 외부 단편화를 줄이기 위한 할당 방식이 있다.
    - 최초 적합
      - 가장 처음 만나는 알맞은 크기의 빈 메모리 공간에 프로세스를 할당
    - 최적 적합
      - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당
    - 최악 적합
      - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 많이 나는 곳에 프로세스를 할당
      - 할당 후 남은 공간에 또 다른 프로세스를 할당할 수 있을 것이라는 가정에 기인

- 불연속 메모리 관리
  - 프로그램을 쪼개 서로 다른 주소에 할당하는 방법이다.
    - 페이지: 고정 사이즈의 작은 프로세스 조각
    - 프레임: 페이지 크기와 같은 주기억장치 메모리 조각
    - 단편화: 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
    - 세그먼트: 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것
  - 페이징은 고정된 크기로 분할하는 방법이고, 세그먼테이션은 가변 크기로 분할하는 방법이다.
  - 단순 페이징
    - 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉜다.
    - 주소 변환을 위해 보조기억장치에서 주기억장치로의 맵핑과정이 필요하다.
      - 페이지 맵핑 테이블이 필요하다.
      - 메모리 낭비가 있다.
  - 가상 메모리 페이징
    - 프로세스 전부를 로드시킬 필요가 없기 때문에 필요한 페이지들만을 로드한다.
    - 복잡한 메모리 관리로 오버헤드가 발생한다.
  - 단순 세그먼테이션
    - 각 프로세스는 여러 세그먼트들로 나뉜다.
  - 가상 메모리 세그먼테이션
    - 필요하지 않은 세그먼트들은 로드되지 않는다.
    - 복잡한 메모리 관리로 오버헤드가 발생한다.



<strong>단편화</strong>

- 내부 단편화
  - 고정 분할 기법에서 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 공간이 남는 상황

- 외부 단편화
  - 프로세스를 할당할 공간은 남아있지만 분할되어 있어 프로세스를 할당하지 못하는 것이다.
- 압축
  - 외부 단편화를 해소하기 위한 방법으로 Scattered Holes를 모으는 방법
  - 메모리에 적재된 프로세스들을 정지시키고 한쪽으로 이동시키는 작업
    - 비용이 굉장히 커 비효율적이다.
    - 어느쪽으로 메모리를 모을지 모호하여 최적 알고리즘이 없다.





## 페이지 교체 알고리즘

<strong>Page Reference String</strong>

CPU는 논리 주소를 통해 특정 주소를 요구한다.

메인 메모리에 올라와 있는 주소들은 페이지의 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나게 되면 페이지 결함이 발생하지 않는다.

따라서 CPU의 주소 요구에 따라 페이지 결함이 일어나지 않는 부분은 생략하여 표시하는 방법이다.



<strong>페이지 교체 알고리즘 종류</strong>

- FIFO(First-in First-out)
  - 먼저 들어온 페이지가 victim page가 된다.
    - 페이지 교체 알고리즘을 통해 교체당하는 페이지를 victim page이라고 한다.
  - 가장 간단한 방법이기 때문에 초기화 코드에 적절한 방법이다.
  - FIFO 모순
    - FIFO에서 더 많은 페이지 프레임을 할당해도 더 많은 페이지 부재가 일어나는 현상을 말한다.
    - 지역성을 반영하지 못하고 순서대로 대치하기 때문이다.
- OPT(Optimal)
  - Belady가 제안한 최적 알고리즘이다.
  - 앞으로 가장 사용하지 않을 페이지를 우선적으로 내보내는 알고리즘
  - 실질적으로 페이지가 잘 사용되지 않을 것이라는 것을 알기 어려워 수행하기 어려운 알고리즘이다.
- LRU(Least-Recently-Used)
  - 최근에 사용하지 않은 페이지를 우선적으로 내보내는 알고리즘
  - 최근에도 사용하지 않으면 나중에도 사용하지 않을 것이라는 것에서 기인
  - 실제로 사용할 수 있는 페이지 교체 알고리즘 중에서 가장 좋은 방법 중 하나이다.



<strong>교체 방식</strong>

- Global 교체
  - 메모리 상의 모든 프로세스 페이지를 교체하는 방식
- Local 교체
  - 메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

페이지 교체 시, 알고리즘에 따라 victim page를 선정하는데, 선정 기준을 Global로 할지 Local로 할지에 대한 차이

실제로는 전체를 기준으로 페이지를 교체하는 것이 효율적이다.