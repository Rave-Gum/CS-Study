## 페이징과 세그먼테이션
- 메모리 관리 기법 사용 이유
    - 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문
- 메모리 관리 기법
    - 연속 메모리 관리
        - 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함
        - 고정 분할 기법: 주기억장치가 고정된 파티션으로 분할(내,외부 단편화 발생)
        - 가변 분할 기법: 스케줄러에 의하여 선택된 프로그램 크기만큼을 가용한 메모리 공간으로부터 배정하여 할당(외부 단편화 발생)
            - 가변 분할 공간 할당 정책
                - 최초적합(First Fit)
                    - 프로그램이 적재 될 수 있는 빈 블록들 중 첫 번째로 발견된 블록에 적재
                - 최적 적합(Best Fit)
                    - 빈 블록들 중 프로그램 크기와 가장 잘 맞는 블록을 찾아 적재
                - 최악적합(Worst Fit)
                    - 적재 가능한 빈 블록들 중 가장 큰  크기를 가진 빈 블록에 적재
    - 불연속 메모리 관리
        - 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
            - 페이지 : 고정 사이즈의 작은 프로세스 조각(논리적 메모리)
            - 프레임: 페이지 크기와 같은 주기억장치 메모리 조각(물리적 메모리)
            - 단편화: 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
            - 세그먼트: 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것
    - 고정 크기: 페이징
    - 가변 크기: 세그먼테이션
    - 단편화
        - 내부 단편화 : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 메모리 공간이 낭비되는 현상
        - 외부 단편화 : 총 여유 공간은 충분하지만 메모리가 작게 쪼개어져 있어서 메모리를 할당할 수 없는 현상
    - 단순 페이징
        - 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
        - 외부 단편화 X
        - 소량의 내부 단편화 존재
    - 단순 세그먼테이션
        - 각 프로세스는 여러 세그먼트들로 나뉨
        - 내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
        - 외부 단편화 존재
    - 가상 메모리 페이징
        - 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요X
        - 필요한 페이지가 있으면 나중에 자동으로 불러들어짐
        - 외부 단편화X
        - 복잡한 메모리 관리로 오버헤드 발생
    - 가상 메모리 세그먼테이션
        - 필요하지 않은 세그먼트들은 로드되지 않음
        - 필요한 세그먼트 있을때 나중에 자동으로 불러들어짐
        - 내부 단편화X
        - 복잡한 메모리 관리로 오버헤드 발생

## 페이지 교체 알고리즘
- FIFO(First-In First-Out) 알고리즘
    - 시간적으로 가장 먼저 메모리에 적재된 페이지를 교체를 위한 페이지로 선택하는 것
    - Belady의 이상현상
        - 프레임의 개수가 증가 될수록 페이지 폴트의 횟수는 줄어드는 것이 일반적
        - FIFO방식에서는 프레임의 개수가 증가되는 경우 오히려 페이지 폴트가 증가되는 현상이 발견되는데 이 현상을 Belady의 이상현상이라고 함
- OPT(Optimal Page Replacement) 알고리즘
    - 현재의 시점에서 향후 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택하는 방법
    - 가장 이상적이지만 미래를 모두 예측해서 프로그램을 운영해야 하기 때문에 구현이 어려움
    - 실제 구현 가능한 다른 방법들과의 성능 비교를 위해 사용
- LRU(Least Recently Used) 알고리즘
    - 현재 시점에서 가장 최근에 사용되지 않은 페이지를 교체하는 기법
    - 최근에 사용한 페이지는 향후에도 재사용될 가능성이 높다는 시간적 구역성(Temporal Locality)을 기반으로 구성
- LFU(Least Frequently Used) 알고리즘
    - 가장 작은 참조 횟수를 가지는 페이지를 교체 대상으로 하는 방식
    - NFU(Not Frequently Used)라고도 불림
- 교체방식
    - Global 교체
        - 메모리 상의 모든 프로세스 페이지에 대해 교체
        - 실제로 효율적인 방식 → 자기 프로세스 페이지에서만 교체하면 교체할 때 각각 모두 교체를 진행해야하므로 비효율적
    - Local 교체
        - 메모리 상의 자기 프로세스 페이지에서만 교체

## 메모리
- 메인 메모리
    - CPU가 직접 접근할 수 있는 접근 장치
    - 프로세스가 실행되려면 프로그램이 메인 메모리에 올라와야 함
- MMU(Memory Management Unit)
    - 논리 주소를 물리주소로 변환해줌
    - 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 관리해줌
    - 한 프로세스에게 함법적인 주소 영역을 설정하고, 잘못된 접근이 오면 `trap`을 발생시켜 메모리를 보호함
- `base`와 `limit` 레지스터를 활용한 메모리 보호
    - `base` : 메모리 상의 프로세스 시작주소를 물리 주소로 저장
    - `limit` : 프로세스의 사이즈를 저장
    - 합법적인 메모리 역역 X는
        - `base ≤ x < base+limit`
        - 이 영역 밖에서 접근을 요구하면 `trap` 발생
    - 안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계
- 메모리 과할당(Over Allocating)
    - 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황
    - 페이징 기법과 같은 메모리 관리 기법은 사용자가 큰 메모리를 사용하는 것처럼 느끼도록 눈속임을 통해 메모리를 할당해줌
    - 과할당 상황에 대해서 사용자를 속인 것을 들킬만한 상황이 존재
        - 프로세스 실행 도중 페이지 폴트 발생
        - 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
        - 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음
    - 이러한 과할당을 해결하기 위해선, 빈 프레임을 확보할 수 있어야 한다..
        - 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음
        - 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용
- 페이지 교체
    - 메모리 과할당이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것
    - Swapping 기법 과정
        1. 페이지 폴트 발생
        2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 Search
        3. 메모리에 빈 프레임이 있는지 확인
        4. 만약 빈 프레임이 있으면 해당 프레임을 사용
        5. 빈 프레임이 없으면, 희생 프레임을 선정해 디스크에 변경 사항을 기록하고 페이지 테이블을 업데이트
        6. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트
    - 페이지 교체가 많이 이루어진다면 오버헤드 문제가 발생하므로 오버헤드를 감소시킬 방법을 강구해야 함
    - 디스크 접근 횟수 줄이기
        - 모든 페이지에 내용의 변경과 관련된 변경 비트를 둔다.
        - 희생(`victim`) 페이지가 정해진다면 변경 비트를 확인한다.
        - 그 비트가 `set` 상태라면 해당 페이지의 내용이 달라졌으므로 디스크에 기록
        - 그 비트가 `clear` 상태라면, 내용이 달라지지 않았으므로 디스크에 접근하지 않아도 됨
    - 페이지 교체 알고리즘 사용
        - 페이지 교체 알고리즘을 상황에 따라 잘 선택한다면 오버헤드를 줄일 수 있다.
        - 즉, 현재 상황에서 페이지 폴트 확률 최대한 줄여줄 수 있는 페이지 교체 알고리즘을 선택해야만 한다.
        - FIFO, OPT, LRU
- 캐시 메모리
    - 주기억 장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
    - CPU와 메인메모리 간의 상능 차이에 대한 성능 저하를 줄이기 위한 대안
    - 만약 CPU가 어떠한 데이터에 대하여 다시 재접근을 할때, 그 데이터를 캐시 메모리에 저장해놨다면 메인 메모리까지 접근할 필요 없음
    - 캐싱 과정
        1. CPU에서 주소를 전달, 해당 명령이 캐시 기억장치에 존재하는지 확인
        2. 존재하면 `hit`, 해당 명령어 CPU에 전달
        3. 존재하지 않으면 `miss`
        4. 주기억장치로 접근
        5. 해당 명령어를 가진 데이터 인출
        6. 해당 명령어 데이터를 캐시에 저장
        7. 해당 명령어를 CPU로 전송
    - 캐시를 이용하면 비용을 많이 줄일 수 있지만, 효율적으로 활용하기 위해선 적중률을 극대화 해야함
        - CPU ↔ 레지스터 - 레지스터에 데이터가 없으면 캐시 메모리에서 찾음
        - 캐시 메모리 - 데이터가 있으면 `hit` 없으면 `miss`
        - 메인 메모리 - 페이지에 데이터가 있으면 `copy` 없으면 `page fault`
        - 하드디스크 -  마지막에 찾는 메모리
    - 지역성(`Locality`)의 원리
        - 기억 장치 내의 데이터를 균등하게 접근하는 것이아니라, 어떠한 순간에 특정한 부분을 집중적으로 접근하는 특성
        - 시간 지역성(`Temporal Locality`): 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
        - 공간 지역성(`Spatial Locality`): 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성
    - 캐싱 라인
        - 캐시를 사용할 때 주소에 해당되는 데이터를 찾기 위해 일일히 순회하는 것은 비효율적
        - 따라서 캐시에 데이터를 저장할 때, 자료구조를 활용하여 메모리 주소를 함께 저장
        - `map` 자료구조와 같이 빠르게 원하는 정보를 찾을 수 있도록 구현

## 파일 시스템
- 컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법
- 특징
    - 커널 영역에서 동작
    - 파일 CRUD 기능을 원활히 수행하기 위한 목적
    - 계층적 디렉터리 구조를 가짐
    - 디스크 파티션 별로 하나씩 둘 수 있음
- 역할
    - 파일 관리
    - 보조 저장소 관리
    - 파일 무결성 메커니즘
    - 접근 방법 제공
- 개발 목적
    - 하드디스크와 메인 메모리 속도차를 줄이기 위함
    - 파일 관리
    - 하드디스크 용량 효율적 이용
- 구조
    - 메타 영역: 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 정보
    - 데이터 영역: 파일의 데이터
- 접근방법
    - 순차 접근(Sequential Access)
        - 가장 간단한 접근 방법, 대부분 연산은 `read`와 `write`
        - 현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 `read`와 `write`를 진행, 뒤로 돌아갈 땐 지정한 `offset`만큼 되감기를 해야 함.
    - 직접 접근(Direct Access)
        - 특별한 순서없이, 빠르게 레코드를 `read`, `write` 가능
        - 현재 위치를 가리키는 `cp` 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현이 가능하다.
        - 무작위 파일 블록에 대한 임의 접근을 허용한다. 따라서 순서의 제약이 없음
        - 대규모 정보를 접근할 때 유용하기 때문에 '데이터베이스'에 활용된다.
    - 기타 접근
        - 직접 접근 파일에 기반하여 색인(`index`) 구축
        - 크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법
    - 디렉터리와 디스크 구조
        - 1단계 디렉터리
            - 가장 간단한 구조
            - 파일들은 서로 유일한 이름을 가짐, 서로 다른 사용자라도 같은 이름 사용 불가

            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc9f4041-88ad-49b2-94e3-0e8cb9a37d0b/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc9f4041-88ad-49b2-94e3-0e8cb9a37d0b/Untitled.png)

        - 2단계 디렉터리
            - 사용자에게 개별적인 디렉터리 만들어줌
            - `UFD` : 자신만의 사용자 파일 디렉터리
            - `MFD` : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리

            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca74fcc7-ed00-40a9-9f72-7bcafee49220/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca74fcc7-ed00-40a9-9f72-7bcafee49220/Untitled.png)

        - 트리 구조 디렉터리
            - 2단계 구조를 확장한 다단계 트리구조
            - 한 비트를 활용하여, 일반 파일(`0`) 디렉터리 파일(`1`) 구분

            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7de23e84-541c-4417-be1b-ae2f5f50ed5e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7de23e84-541c-4417-be1b-ae2f5f50ed5e/Untitled.png)

        - 그래프 구조 디렉터리
            - 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시
            - 링크가 있으면 우회하여 순환을 피할 수 있음

            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7d35364-4a71-4c9a-8d7b-7b5d1f7875db/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7d35364-4a71-4c9a-8d7b-7b5d1f7875db/Untitled.png)