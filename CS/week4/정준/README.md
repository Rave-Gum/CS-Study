## CPU 스케줄링
- CPU 스케줄링
    - 메모리에 올라온 프로세스들중 어떤 프로세스를 먼저 처리할지 순서를 정하는 일
- 스케줄링의 조건
    - 오버헤드를 줄이고, 사용률을 높이며 기아 현상을 줄이는 것
- 스케줄링의 목표
    - `Batch System`: 가능하면 많은 일을 수행, 시간(`time`)보다 처리량(`throughout`)이 중요
    - `Interactive System`: 빠른 응답 시간, 적은 대기 시간
    - `Real-time System`: 기한(`DeadLine`) 맞추기
- 선점 스케줄링(`Preemptive Scheduling`)
    - 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링
    - 종류
        - Priority Scheduling
            - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
            - 우선 순위가 낮은 프로세스가 무한정 기다리는 기아상태(`Starvation`)가 생길 수 있음
            - `Aging` 방법으로 기아 문제 해결 가능 (대기시간이 경과 할수록 우선순위가 높아짐)
        - RR(Round Robin)
            - 시간 할당량 동안만 실행한 후 완료되지 않으면 다음 프로세스에게 CPU를 양보하고 준비상태 큐의 가장 뒤로 배치
            - TQ(Time Quantum)이 클수록 FIFO와 유사, 작을수록 문맥교환 및 오버헤드 발생
        - MultiLevel Queue(다단계 큐)
            - 준비 큐를 여러 개 두고 각 준비 큐마다 다른 스케줄링 방식을 사용하는 스케줄링
            - 우선순위별로 큐를 나누어 처리
        - MultiLevel Feedback Queue(다단계 피드백 큐)
            - 다단계 큐 스케줄링에서는 우선순위가 낮은 준비 큐에 배치된 프로세스들의 기아현상이 발생할 수 있는데 이를 방지하기 위해 준비 큐 사이에 프로세스들이 이동할 수 있는 방법을 제공하는 스케줄링
- 비선점 스케줄링(`Non-Preemptive Scheduling`)
    - 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링
    - 종류
        - FCFS(First Com First Served)
            - 준비상태의 큐에 도착한 순서로 CPU를 할당 받는 기법
        - SJF(Short Job First)
            - 준비상태 큐에 있는 프로세스들 중에 실행시간이 짧은 프로세스에 먼저 CPU를 할당하는 기법 (비현실적임, 현실에서는 프로세스가 CPU를 얼마나 사용할지 알 수 없기 때문)
            - 기아상태(`Starvation`) 발생
        - HRN(Highest Response Ratio Next)
            - SJF + Aging 형태, SJF의 단점(기아현상)을 Aging 방법으로 보완한 방식


## 데드락
- 데드락(DeadLock)
    - 프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
    - 교착상태라고도 부름
    - 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생
- 데드락 발생 조건
    - 4가지 모두 성립해야 데드락 발생
    - 상호배제(Mutaul Exclusion)
        - 자원은 한번에 한 프로세스만 사용 가능
    - 점유 대기(Hold And Wait)
        - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
    - 비선점(No Preemption)
        - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
    - 순환 대기(Circular Wait)
        - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
- 데드락 처리
    - 예방(Prevention)
        - 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법
        - 자원의 낭비가 심하다.
            - 상호배제 부정
                - 여러 개의 프로세스가 공유자원을 사용 할 수 있도록 한다.
            - 점유 대기 부정
                - 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.
            - 비선점 부정
                - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 한다.
            - 순환 대기 부정
                - 자원에 고유한 번호를  할당하고 번호 순서대로 자원을 요구하도록 한다.
    - 회피(Avoidance)
        - 교착상태가 발생하면 피해나가는 방법
        - 은행원 알고리즘(Banker's Algorithm)
            - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착항태를 회피하는 기법
    - 탐지(Detection)
        - 자원 할당 그래프를 통해 교착 상태를 탐지
        - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
    - 회복(Recovery)
        - 교착 상태 일으킨 프로세를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
        - 프로세스 종료 방법
            - 교착 상태의 프로세스를 모두 중지
            - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
        - 자원 선점 방법
            - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당
            - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점


## 경쟁 상태
- 경쟁 상태(Race Condition)
    - 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태
    - 동시 접근 시 자료의 일관성을 해치는 결과가 나타남
- 경쟁 상태가 발생하는 경우
    - 커널 작업을 수행하는 중에 인터럽트 발생
        - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
        - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트응 disable시켜 CPU 제어권을 가져가지 못하도록 한다.
    - 프로세스가 `System Call`을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때
        - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우(프로세스2가 작업에 반영되지 않음)
        - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
    - 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때
        - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
        - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법


## 세마포어 & 뮤텍스
- 세마포어(Semaphore)
    - 현재공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법
    - 장점 : 임계 영역에 진입하지 못한 프로세스들이 `Busy Waiting` 하지 않고 CPU 자원을 반납
- 세마포어 P, V 연산
    - P(Proberen) : 임계 구역 들어가기 전에 수행(프로세스 진입 여부를 자원의 개수(S)를 통해 결정)
    - V(Verhogen) : 임계 구역에서 나올 때 수행(자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)
- 뮤텍스(Mutex)
    - 한 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제기법
    - 상호 배제의 약자 (**Mut**ual **Ex**clusion)
    - 접근을 조율하기 위해 lock과 unlock을 사용
        - lock : 현재 임계 구역에 들어갈 권한을 얻어옴(만약 다른 프로세스/스레드가 사용중이면 종료할 때까지 대기)
        - unlock : 현재 임계 구역을 모두 사용했음을 알림(대기 중인 다른 프로세스/르세드가 진입할 수 있음)
    - 상태가 0, 1로 이진 세마포어로 부르기도 함
- 뮤텍스 알고리즘
    - 데커(Dekker) 알고리즘
        - `flag`와 `turn` 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식
        - `flag` : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
        - `turn` : 누가 임계구역에 들어갈 차례인지 나타내는 변수

        ```kotlin
        while(true) {
            flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
            while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
                if(turn == j) { // j가 임계 구역 사용 중이면
                    flag[i] = false; // 프로세스 i 진입 취소
                    while(turn == j); // turn이 j에서 변경될 때까지 대기
                    flag[i] = true; // j turn이 끝나면 다시 진입 시도
                }
            }
        }

        // ------- 임계 구역 ---------

        turn = j; // 임계 구역 사용 끝나면 turn을 넘김
        flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
        ```

    - 피터슨(Peterson) 알고리즘
        - 데커와 유사하지만, 상대방 프로세스.스레드에게 진입 기회를 양보하는 것에 차이가 있음

        ```kotlin
        while(true) {
            flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
            turn = j; // 다른 프로세스에게 진입 기회 양보
            while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
            }
        }

        // ------- 임계 구역 ---------

        flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
        ```

    - 제과점(Bakery) 알고리즘
        - 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘, 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입

        ```kotlin
        while(true) {
            
            isReady[i] = true; // 번호표 받을 준비
            number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
            isReady[i] = false; // 번호표 수령 완료
            
            for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
                while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
                while(number[j] && number[j] < number[i] && j < i);
                
                // 프로세스 j가 번호표 가지고 있어야 함
                // 프로세스 j의 번호표 < 프로세스 i의 번호표
            }
        }

        // ------- 임계 구역 ---------

        number[i] = 0; // 임계 구역 사용 종료
        ```